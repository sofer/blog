<!DOCTYPE html>
<html>
<head>
<title>Misadventures with Restful Authentication</title>
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
<link href="/stylesheets/print.css" media="print" rel="stylesheet" type="text/css" />
<!--[if lt IE 8]>
    <link href="/stylesheets/ie.css" media="screen, projection" rel="stylesheet" type="text/css" />
<![endif]-->
</head>

<body>
<h1>Misadventures with Restful Authentication</h1>

<p>This may seem trivial to some people, but I got a bit confused finding a path through the <a href="http://github.com/technoweenie/restful-authentication">Restful Authentication plugin</a> for Rails.</p>
<p>To restrict access inside a controller, I originally put this line inside the controller class:</p>
<p><code>before_filter :authorize</code></p>
<p>This invokes an <code>authorize</code> method before any actions in the controller are called.</p>
<p><code>authorize</code> is a private method that I put inside the class <code>ApplicationController</code>. It checks the <code>logged_in?</code> method, setting an <code>:original_uri</code> value in the Rails session object and then redirecting users to a login page, if required (it&#8217;s private because methods in <code>ApplicationController</code> are available as instance methods in all other controllers and so public methods would be exposed to end users as actions).</p>
<p><code>logged_in</code> is a protected method inside the <code>AuthenticatedSystem</code> module (which needs to be included in <code>ApplicationController</code>, so that the <code>logged_in?</code> method is available to it).</p>
<p><code>logged_in?</code> in turn calls the <code>current_user</code> method also in <code>AuthenticatedSystem</code> (and all the action described from here on in takes place inside this module), which attempts to identify the user from (in order) the Rails session object, standard <span class="caps">HTTP</span> authentication headers and then any cookies that might have been set. Otherwise it returns false and <code>session[:original_uri]</code> is set before the user is redirected to a login page.</p>
<p>It turns out that there is also a <code>:return_to</code> key in the <code>Session</code> object, which sounds like it might be used for the same thing as <code>:orginal_uri</code>, and like <code>:original_uri</code> gets its value from <code>request.request_uri</code>. But <code>:return_to</code> only gets set when the <code>login_required?</code> method is called, which in turn calls <code>logged_in?</code> as well as setting the value of <code>:return_to</code> and giving a hook to extend the default behaviour to something more complex than just checking whether a user is logged in.</p>
<p>The problem for me is that I have been using the method <code>redirect_back_or_default</code> to get users back to where they were going before logging in and this method uses <code>:return_to</code> and not <code>:original_uri</code>.</p>
<p>Reading the very helpful comments left in the <code>AuthenticatedSystem</code> class by its authors it has now become obvious that I have made a significant design mistake: I added an added layer of complexity, i.e. the <code>:authorize</code> method, where none was needed, and then compounded my error by accessing the <code>logged_in</code> method directly instead of going through <code>login_required</code>.</p>
<p>Upshot: unexpected behaviour in my application leading to much frustration.</p>
<p>Moral: When somebody leaves very helpful comments in their code, read the comments before using the code.</p>
</body>
</html>